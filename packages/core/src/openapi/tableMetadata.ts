import type { Introspection, TableSpec } from './schemaIntrospect'

export interface GeneratedMetadata {
  tables: {
    name: string
    primaryKey?: string | string[]
    columns: { name: string; type: string; required: boolean }[]
  }[]
}

export function toMetadataJSON(intro: Introspection): GeneratedMetadata {
  return {
    tables: intro.tables.map((t) => ({
      name: t.name,
      primaryKey: t.primaryKey,
      columns: t.columns.map((c) => ({ name: c.name, type: c.type, required: c.required })),
    })),
  }
}

export function emitTablesDTS(intro: Introspection): string {
  const lines: string[] = []
  lines.push('// Generated by @postgrestx/core generate-types. Do not edit.\n')
  for (const t of intro.tables) {
    const iface = emitTableInterface(t)
    lines.push(iface, '\n')
  }
  return lines.join('\n')
}

function emitTableInterface(t: TableSpec): string {
  const name = safeTypeName(t.name)
  const fields = t.columns
    .map((c) => `  ${JSON.stringify(c.name)}${c.required ? '' : '?'}: ${c.type}`)
    .join('\n')
  return `export interface ${name} {\n${fields}\n}`
}

function safeTypeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^\d+/, (m) => `T_${m}`)
}

export function emitOperatorsDTS(): string {
  // For MVP, emit a simple operator map by primitive category. Future: per-column operators.
  return `// Generated by @postgrestx/core generate-types. Do not edit.\n\nexport type StringOps = { eq?: string; neq?: string; like?: string; ilike?: string; in?: string[] }\nexport type NumberOps = { eq?: number; neq?: number; gt?: number; gte?: number; lt?: number; lte?: number; in?: number[] }\nexport type BooleanOps = { eq?: boolean; is?: boolean }\nexport type DateOps = { eq?: string; neq?: string; gt?: string; gte?: string; lt?: string; lte?: string }\nexport type JsonOps = { contains?: unknown; containedBy?: unknown; overlaps?: unknown }\n`
}
